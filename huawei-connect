#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import time
import logging
import subprocess
import tempfile
import re
import pexpect
import argparse


class ModemStateBase(object):
    def __init__(self, context):
        super(ModemStateBase, self).__init__()
        self._context = context

    def find(self):
        raise NotImplementedError()

    def reset(self):
        raise NotImplementedError()

    def open(self):
        raise NotImplementedError()

    def close(self):
        raise NotImplementedError()

    def start(self):
        raise NotImplementedError()

    def signal_strength(self):
        raise NotImplementedError()

    def network_info(self):
        raise NotImplementedError()


class ModemException(Exception):
    pass


class ModemNotFound(ModemException):
    pass


class ModemHardwareException(ModemException):
    pass


class ModemCommunitationError(ModemHardwareException):
    pass


class ModemStateNotFound(ModemStateBase):

    _not_found_err_msg = "modem is not found, call method find() first"

    def __init__(self, context):
        super(ModemStateNotFound, self).__init__(context)
        self.logger = logging.getLogger("modem:not_found")

        self._context.tty = None
        self._context.iface = None

    def find(self):
        device_path = self._find_usb_device_path()
        if device_path is None:
            self.logger.debug("device usb path isn't found")
            return False
        self.logger.debug("device usb path is found: %s", device_path)

        tty = self._find_tty(device_path)
        if tty is None:
            err_msg = "modem is found but tty isn't found"
            self.logger.error(err_msg)
            raise ModemHardwareException(err_msg)
        self.logger.debug("tty path is found: %s", tty)

        iface = self._find_iface(device_path)
        if iface is None:
            err_msg = "modem is found but network interface isn't found"
            self.logger.error(err_msg)
            raise ModemHardwareException(err_msg)
        self.logger.debug("network interface is found: %s", iface)

        self._context.tty = tty
        self._context.iface = iface
        self._context.state = "closed"
        return True

    def _find_usb_device_path(self):
        usb_devices_path = "/sys/bus/usb/devices"
        usb_devices_list = os.listdir(usb_devices_path)
        for device in usb_devices_list:
            device_path = os.path.join(usb_devices_path, device)
            idVendor_path = os.path.join(device_path, "idVendor")
            idProduct_path = os.path.join(device_path, "idProduct")
            if not os.path.exists(idVendor_path) or not os.path.exists(idProduct_path):
                continue
            idVendor = open(idVendor_path).read().strip()
            if idVendor != self._context.vendor_id:
                continue
            idProduct = open(idProduct_path).read().strip()
            if idProduct != self._context.product_id:
                continue
            return self._symlink_abs_path(device_path)

    @staticmethod
    def _symlink_abs_path(relative_symlink):
        return os.path.normpath(
            os.path.join(
                os.path.dirname(relative_symlink),
                os.readlink(relative_symlink)
            )
        )

    @classmethod
    def _find_tty(cls, device_path):
        usb_serial_path = "/sys/bus/usb-serial/devices"
        for tty in os.listdir(usb_serial_path):
            tty_symlink = os.path.join(usb_serial_path, tty)
            abs_tty_path = cls._symlink_abs_path(tty_symlink)
            if abs_tty_path.startswith(device_path):
                tty_dev_path = os.path.join("/dev", tty)
                if os.path.exists(tty_dev_path):
                    return tty_dev_path

    @classmethod
    def _find_iface(cls, device_path):
        net_path = "/sys/class/net"
        for iface in os.listdir(net_path):
            iface_symlink = os.path.join(net_path, iface)
            abs_iface_path = cls._symlink_abs_path(iface_symlink)
            if abs_iface_path.startswith(device_path):
                return iface

    def reset(self):
        argv = ("usb_modeswitch", "-R",
                "-v", self._context.vendor_id,
                "-p", self._context.product_id)
        self.logger.debug("execute '{}'".format(" ".join(argv)))
        proc = subprocess.Popen(argv, stdin=None, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, stderr = proc.communicate()
        retcode = proc.returncode

        self.logger.debug("%s return code: %d", argv[0], retcode)
        if stderr:
            self.logger.debug("%s stderr:\n%s", argv[0], stderr)
        if stdout:
            self.logger.debug("%s stdout:\n%s", argv[0], stdout)

        if retcode != 0:
            err_msg = "{} dies with code {}".format(argv[0], retcode)
            self.logger.error(err_msg)
            raise ModemHardwareException(err_msg)

    def open(self):
        raise ModemException(self._not_found_err_msg)

    def close(self):
        raise ModemException(self._not_found_err_msg)

    def start(self):
        raise ModemException(self._not_found_err_msg)

    def signal_strength(self):
        raise ModemException(self._not_found_err_msg)

    def network_info(self):
        raise ModemException(self._not_found_err_msg)


class ModemStateClosed(ModemStateBase):

    _reset_timeout = 10
    _not_opened_msg = "modem isn't opened, call method open() first"

    def __init__(self, context):
        super(ModemStateClosed, self).__init__(context)
        self.logger = logging.getLogger("modem:closed")

    def find(self):
        self._context.state = "not_found"
        return self._context.find()

    def reset(self):
        self._context.state = "not_found"
        self._context.reset()

        die_time = time.time() + self._reset_timeout
        while die_time > time.time():
            if self._context.find():
                break
            time.sleep(0.5)
        else:
            err_msg = "modem haven't returned to life after reset"
            self.logger.error(err_msg)
            raise ModemHardwareException(err_msg)

    def open(self):
        self._context.state = "opened"

    def close(self):
        pass

    def start(self):
        raise ModemException(self._not_opened_msg)

    def signal_strength(self):
        raise ModemException(self._not_opened_msg)

    def network_info(self):
        raise ModemException(self._not_opened_msg)


class pexpect_logger(object):
    def __init__(self, logger, action):
        super(pexpect_logger, self).__init__()
        self.logger = logger
        self.action = action

    def write(self, msg):
        for line in msg.split("\n"):
            line = "".join(c for c in line if c >= " ")
            if not line:
                continue
            self.logger.debug("%s:%s", self.action, line)

    def flush(self):
        pass


class ModemConnection(object):

    _expect_timeout_msg = "modem haven't sent what was expected until timeout"
    _screen_init_time = 2

    def __init__(self, tty):
        super(ModemConnection, self).__init__()
        self.logger = logging.getLogger("modem:tty")

        self._screen_cfg_path = tempfile.mkstemp(prefix="screen_", suffix=".cfg")[1]
        with open(self._screen_cfg_path, "w") as fp:
            fp.write("startup_message off\n")
            fp.write("hardstatus off\n")
        argv = ("screen", "-c", self._screen_cfg_path, tty, "9600")

        self.logger.debug("spawn '{}'".format(" ".join(argv)))
        self._tty = pexpect.spawn(argv[0], args=list(argv[1:]))
        self._tty.setecho(False)
        time.sleep(self._screen_init_time)
        try:
            # consume all screen output
            self._tty.read_nonblocking(0xFFFF, timeout=0)
        except pexpect.TIMEOUT:
            pass
        self._tty.logfile_read = pexpect_logger(self.logger, "read")
        self._tty.logfile_send = pexpect_logger(self.logger, "send")

        self.send("AT", "OK", timeout=10)
        self.send("AT^CURC=0", "OK")

    def send(self, command, patterns=None, timeout=5):
        if not self._tty.isalive():
            err_msg = "tty connection have died"
            self.logger.error(err_msg)
            raise ModemHardwareException(err_msg)

        self._tty.send(command + "\r\n")

        if patterns is None:
            return None

        try:
            self._tty.expect_exact(patterns, timeout=timeout)
        except pexpect.TIMEOUT:
            self.logger.error(self._expect_timeout_msg)
            raise ModemCommunitationError(self._expect_timeout_msg)
        return self._tty.match

    _re_match_type = re.match(r"", "").__class__

    def expect(self, patterns, timeout=5):
        try:
            self._tty.expect(patterns, timeout=timeout)
        except pexpect.TIMEOUT:
            self.logger.error(self._expect_timeout_msg)
            raise ModemCommunitationError(self._expect_timeout_msg)
        match = self._tty.match
        if not isinstance(match, self._re_match_type):
            self.logger.error(self._expect_timeout_msg)
            raise ModemCommunitationError(self._expect_timeout_msg)
        return match

    def isalive(self):
        return self._tty.isalive()

    def close(self, force=False):
        self.logger.debug("close")
        self._tty.close(force)

        self.logger.debug("remove '%s'", self._screen_cfg_path)
        os.remove(self._screen_cfg_path)


class ModemStateOpened(ModemStateBase):

    def __init__(self, context):
        super(ModemStateOpened, self).__init__(context)
        self.logger = logging.getLogger("modem:opened")
        self._conn = ModemConnection(self._context.tty)

    def find(self):
        self.close()
        return self._context.find()

    def open(self):
        pass

    def close(self):
        if self._conn.isalive():
            self._conn.close(force=True)
        self._context.state = "closed"

    def start(self):
        self._conn.send("ATZ", "OK")
        self._conn.send("ATQ0 V1 E1 S0=0", "OK")
        self._conn.send(
            'AT^NDISDUP=1,1,"{}"'.format(self._context.apn),
            "^NDISSTAT"
        )
        self._conn.send("AT^DHCP?", "^DHCP:")
        self._setup_iface()

    def _setup_iface(self):
        argv = ("dhclient", self._context.iface)
        self.logger.debug("execute '{}'".format(" ".join(argv)))
        proc = subprocess.Popen(argv, stdin=None, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, stderr = proc.communicate()
        retcode = proc.returncode

        self.logger.debug("%s return code: %d", argv[0], retcode)
        if stderr:
            self.logger.debug("%s stderr:\n%s", argv[0], stderr)
        if stdout:
            self.logger.debug("%s stdout:\n%s", argv[0], stdout)

        if retcode != 0:
            err_msg = "{} died with code {}".format(argv[0], proc.returncode)
            self.logger.error(err_msg)
            raise ModemCommunitationError(err_msg)

    def reset(self):
        self.close()
        self._context.reset()
        self._context.open()

    _regex_signal_strength = re.compile(r"\+CSQ: (?P<rssi>\d+),(?P<ber>\d+)")

    def signal_strength(self):
        # pylint: disable=E1103
        # ModemConnection.expect always return re.match object

        self._conn.send("AT+CSQ")
        match = self._conn.expect(self._regex_signal_strength)
        rssi = int(match.group("rssi"))
        if rssi == 99:
            return -1
        return rssi

    _regex_network_info = re.compile(
        r"\+COPS: (?P<mode>[0-4])(?:,(?P<format>[0-2]),(?P<oper>\".*\"),(?P<act>[0-7]))?")

    def network_info(self):
        # pylint: disable=E1103
        # ModemConnection.expect always return re.match object

        self._conn.send("AT+COPS?")
        match = self._conn.expect(self._regex_network_info)

        oper = match.group("oper")
        if oper:
            oper = oper.strip('"')
        else:
            oper = "unknow"

        # 0 GSM                        = 2G or 2.5G if GPRS
        # 1 GSM Compact                = 2G or 2.5G if GPRS
        # 2 UTRAN                      = 3G
        # 3 GSM with EGPRS             = 2.75G
        # 4 UTRAN with HSDPA           = 3G
        # 5 UTRAN with HSUPA           = 3G
        # 6 UTRAN with HSDPA and HSUPA = 3G
        # 7 E-UTRAN                    = 4G (LTE)
        act = match.group("act")
        if act is None:
            act = "N/A"
        else:
            act = int(act)
            if act <= 1:
                act = "2G"
            elif act == 2:
                act = "3G"
            elif act == 3:
                act = "2G+"
            elif 4 <= act <= 6:
                act = "3G+"
            elif act == 7:
                act = "4G"

        return act, oper

class Modem(object):

    vendor_id = "12d1"
    product_id = "1506"

    _states = {
        "not_found": ModemStateNotFound,
        "closed": ModemStateClosed,
        "opened": ModemStateOpened,
    }

    def __init__(self, apn):
        super(Modem, self).__init__()
        self.logger = logging.getLogger(self.__class__.__name__)

        self.apn = apn
        self.tty = None
        self.iface = None

        self._state = None
        self._state_str = None
        self.state = "not_found"

    @property
    def state(self):
        return self._state_str

    @state.setter
    def state(self, value):
        if value not in self._states:
            raise ValueError("unknow state: {}".format(value))
        self.logger.debug("change state to '%s'", value)
        self._state = self._states[value](self)
        self._state_str = value

    @property
    def states(self):
        return self._states.keys()

    @property
    def found(self):
        return self.state != "not_found"

    @property
    def closed(self):
        return self.state != "opened"

    def find(self):
        self.logger.debug("find()")
        return self._state.find()

    def open(self):
        self.logger.debug("open()")
        self._state.open()

    def close(self):
        self.logger.debug("close()")
        self._state.close()

    def start(self):
        self.logger.debug("start()")
        self._state.start()

    def reset(self):
        self.logger.debug("reset()")
        self._state.reset()

    def signal_strength(self):
        return self._state.signal_strength()

    def network_info(self):
        return self._state.network_info()


def setup_logging(quite, debug):
    if quite:
        stream = open("/dev/null", "w")
    else:
        stream = sys.stderr
    logging.basicConfig(
        stream=stream,
        level="DEBUG" if debug else "ERROR"
    )


def monitor(modem, mask, interval):
    while True:
        try:
            ss = modem.signal_strength()
            at, op = modem.network_info()
        except ModemCommunitationError:
            pass
        else:
            sys.stdout.write(mask.format(ss=ss, at=at, op=op))
            sys.stdout.flush()
        time.sleep(interval)


def main(argv=sys.argv):
    parser = argparse.ArgumentParser(
        prog=argv[0],
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Huawei E3276 connect program",
        epilog="""\
FORMAT controls output. Interpreted sequences are:
  {ss}   signal strength: -1..31
  {at}   access technology: 2G, 2G+, 3G, 3G+, 4G or unknow
  {op}   operator string
"""
    )
    parser.add_argument(
        "-v", "--version",
        action="version",
        version="%(prog)s v1.0.1"
    )
    parser.add_argument(
        "-m", "--monitor",
        metavar="FORMAT",
        type=str,
        dest="mask",
        nargs="?",
        const="{ss}\t{at}\t{op}\n",
        help=("start monitoring after a connection. Default format is "
              "'{ss}\\t{at}\\t{op}\\n'")
    )
    parser.add_argument(
        "-i", "--interval",
        metavar="SEC",
        type=int,
        default=10,
        help="interval in seconds between requests while monitoring"
    )
    parser.add_argument(
        "-q", "--quite",
        action="store_true",
        help="suppress all error messages"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="print debug messages to stderr"
    )
    args = parser.parse_args(argv[1:])

    setup_logging(args.quite, args.debug)

    modem = Modem(apn="internet")
    if not modem.find():
        print "{}: modem is not found".format(argv[0])
        return 1
    modem.reset()
    modem.open()
    try:
        modem.start()
    except ModemCommunitationError:
        print "{}: can't connect to the Internet".format(argv[0])
    if args.mask:
        try:
            monitor(modem, args.mask, args.interval)
        except KeyboardInterrupt:
            pass
    modem.close()
    return 0


if __name__ == "__main__":
    sys.exit(main())
